<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>

<HEAD>
	<TITLE>
	libsndfile : Frequently Asked Questions.
	</TITLE>
	<META NAME="Author"      CONTENT="Erik de Castro Lopo (erikd AT mega-nerd DOT com)">
	<META NAME="Description" CONTENT="The libsndfile FAQ.">
	<META NAME="Keywords"    CONTENT="WAV AIFF AU libsndfile sound audio dsp Linux">
	<LINK REL=StyleSheet HREF="libsndfile.css" TYPE="text/css" MEDIA="all">
</HEAD>

<BODY TEXT="#FFFFFF" BGCOLOR="#000000" LINK="#5050FF" VLINK="#5050FF" ALINK="#FF00FF">

<H1><B>libsndfile : Frequently Asked Questions.</B></H1>
<P>
<A HREF="#Q001">Q1 : On Linux, sf_open returns weird info about files. Why?</A><BR>
<A HREF="#Q002">Q2 : In version 0 the SF_INFO struct had a pcmbitwidth field
		but version 1 does not. Why?</A><BR>
<A HREF="#Q003">Q3 : Compiling is really slow on MacOSX. Why?</A><BR>
<A HREF="#Q004">Q4 : When trying to compile libsndfile on Solaris I get a "bad
		substitution" error during linking. What can I do to fix this?</A><BR>
<A HREF="#Q005">Q5 : Why doesn't libsndfile do interleaving/de-interleaving?</A><BR>
<A HREF="#Q006">Q6 : What's the best format for storing temporary files?</A><BR>
<A HREF="#Q007">Q7 : On Linux/Unix/MaxOSX, what's the best way of detecting the
	presence of libsndfile?</A><BR>
<A HREF="#Q008">Q8 : How about adding the ability to write/read sound files to/from
	memory buffers?</A><BR>
<A HREF="#Q009">Q9 : Reading a 16 bit PCM file as normalised floats and then 
	writing them back changes some sample values. Why?</A><BR>
<A HREF="#Q010">Q10 : I'm having problems with u-law encoded WAV files generated by 
	libsndfile in Winamp. Why?</A><BR>
<A HREF="#Q011">Q11 : What are samples? What are frames?</A><BR>
<HR>

<!-- ========================================================================= -->
<A NAME="Q001"></A>
<H2><BR><B>Q1 : On Linux, sf_open returns weird info about files. Why?</B></H2>
<P>
	This simple call to sf_open :
</P>
<PRE>
        file = sf_open (filename, SFM_READ, &amp;sfinfo) ;

        printf ("srate    : %d\n", sfinfo.samplerate) ;
        printf ("frames   : %d\n", sfinfo.frames) ;
        printf ("channels : %d\n", sfinfo.channels) ;
        printf ("format   : %d\n", sfinfo.format) ;
        printf ("sections : %d\n", sfinfo.sections);
        printf ("seekable : %d\n", sfinfo.seekable) ;
</PRE>
<P>
returns this weird info:
</P>
<PRE>
        srate     : 0
        frames    : 1445760
        channels  : 44100
        format    : 2
        sections  : 65538
        seekable  : 1

</PRE>
<H2><B>Answer</B></H2>
<P>
This is only a problem on Linux and other 32 bit OSes (possibly 32 bit Solaris)
which require special compiler command line options to allow access to files
greater than 2 Gig in size.
<A HREF="pkgconfig.html">These instructions</A> should show you a way around this
problem.
</P>

<!-- ========================================================================= -->
<A NAME="Q002"></A>
<H2><BR><B>Q2 : In version 0 the SF_INFO struct had a pcmbitwidth field
		but version 1 does not. Why?</B></H2>
<P>
	This was dropped for a number of reasons:
</P>
<UL>
	<LI> pcmbitwidth makes little sense on compressed or floating point formats
	<LI> with the new API you really don't need to know it
</UL>
<P>
As documented
    <A HREF="http://www.mega-nerd.com/libsndfile/api.html#note1">here</A>
there is now a well defined behavior which ensures that no matter what the
bit width of the source file, the scaling always does something sensible.
This makes it safe to read 8, 16, 24 and 32 bit PCM files using sf_read_short()
and always have the optimal behavior.
</P>

<!-- ========================================================================= -->
<A NAME="Q003"></A>
<H2><BR><B>Q3 : Compiling is really slow on MacOSX. Why?</B></H2>
<P>
When you configure and compile libsndfile, it uses the Bourne shell for a number
of tasks (ie configure script and libtool).
However, Apple has decided to ship their system with a really crappy Bourne shell.
</P>
<P>
To fix this I suggest that you install the GNU Bash shell, rename /bin/sh to
/bin/sh.old and make a softlink from /bin/sh to the bash shell.
Bash is designed to behave as a Bourne shell when is is called as /bin/sh.
</P>
<P>
When I did this on my iBook running MacOSX, compile times dropped from 13 minutes 
to 3 minutes.
</P>

<!-- ========================================================================= -->
<A NAME="Q004"></A>
<H2><BR><B>Q4 : When trying to compile libsndfile on Solaris I get a "bad
		substitution" error on linking. Why?</B></H2>
<P>
It seems that the Solaris Bourne shell disagrees with GNU libtool.
</P>
<P>
To fix this I suggest that you install the GNU Bash shell, rename /bin/sh to
/bin/sh.old and make a softlink from /bin/sh to the bash shell.
Bash is designed to behave as a Bourne shell when is is called as /bin/sh.
</P>

<!-- ========================================================================= -->
<A NAME="Q005"></A>
<H2><BR><B>Q5 : Why doesn't libsndfile do interleaving/de-interleaving?</B></H2>
<P>
This problem is bigger than it may seem at first.
</P>
<P>
For a stereo file, it is a pretty safe bet that a simple interleaving/de-interleaving
could satisfy most users.
However, for files with more than 2 channels this is unlikely to be the case.
If the user has a 4 channel file and want to play that file on a stereo output 
sound card they either want the first two channels or they want some mixed combination 
of the 4 channels.
</P>
<P>
When you add more channels, the combinations grow exponentially and it becomes
increasingly difficult to cover even a sensible subset of the possible combinations.
On top of that, coding any one style of interleaver/de-interleaver is trivial, while
coding one that can cover all combinations is far from trivial.
This means that this feature will not be added any time soon.
</P>

<!-- ========================================================================= -->
<A NAME="Q006"></A>
<H2><BR><B>Q6 : What's the best format for storing temporary files?</B></H2>

<P>
When you want to store temporary data there are a number of requirements;
</P>
<UL>
	<LI> A simple, easy to parse header.
	<LI> The format must provide the fastest possible read and write rates (ie
		avoid conversions and encoding/decoding).
	<LI> The file format must be reasonably common and playable by most players.
	<LI> Able to store data in either endian-ness.
</UL>
<P>
The format which best meets these requirements is AU, which allows data to be
stored in any one of short, int, float and double (among others) formats.
</P>
<P>
For instance, if an application uses float data internally, its temporary files
should use a format of (SF_ENDIAN_CPU | SF_FORMAT_AU | SF_FORMAT_FLOAT) which
will store big endian float data in big endian CPUs and little endian float data
on little endian CPUs.
Reading and writing this format will not require any conversions or byte swapping
regardless of the host CPU.
</P>

<!-- ========================================================================= -->

<A NAME="Q007"></A>
<H2><BR><B>Q7 : On Linux/Unix/MaxOSX, what's the best way of detecting the presence
	of libsndfile using autoconf?</B></H2>

<P>
libsndfile uses the pkg-config (man pkg-config) method of registering itself with the
host system.
The best way of detecting its presence is using something like this in configure.ac
(or configure.in):
</P>
<PRE>
        PKG_CHECK_MODULES(SNDFILE, sndfile >= 1.0.2, ac_cv_sndfile=1, ac_cv_sndfile=0)

        AC_DEFINE_UNQUOTED([HAVE_SNDFILE],${ac_cv_sndfile},
			[Set to 1 if you have libsndfile.])

        AC_SUBST(SNDFILE_CFLAGS)
        AC_SUBST(SNDFILE_LIBS)
</PRE>
<P>
This will automatically set the <B>SNDFILE_CFLAGS</B> and <B>SNDFILE_LIBS</B>
variables which can be used in Makefile.am like this:
</P>
<PRE>
        SNDFILE_CFLAGS = @SNDFILE_CFLAGS@
        SNDFILE_LIBS = @SNDFILE_LIBS@
</PRE>
<P>
If you install libsndfile from source, you will probably need to set the
<B>PKG_CONFIG_PATH</B> environment variable as suggested at the end of the
libsndfile configure process. For instance on my system I get this:
</P>
<PRE>
        -=-=-=-=-=-=-=-=-=-= Configuration Complete =-=-=-=-=-=-=-=-=-=-

          Configuration summary :

            Version : ..................... 1.0.5
            Experimental code : ........... no

          Tools :

            Compiler is GCC : ............. yes
            GCC major version : ........... 3

          Installation directories :

            Library directory : ........... /usr/local/lib
            Program directory : ........... /usr/local/bin
            Pkgconfig directory : ......... /usr/local/lib/pkgconfig

        Compiling some other packages against libsndfile may require
        the addition of "/usr/local/lib/pkgconfig" to the
        PKG_CONFIG_PATH environment variable.
</PRE>

<!-- ========================================================================= -->

<A NAME="Q008"></A>
<H2><BR><B>Q8 : How about adding the ability to write/read sound files to/from
	memory buffers?</B></H2>

<P>
I have a had a number of requests like this over the last 18 months.
As yet, no-one has been able to justify why this is a good idea and why this
cannot be done in a different way.
</P>
<P>
One example of a different way is temporary files stored on a temporary file
system (ie tmpfs on both Linux and Solaris).
These require no changes to libsndfile, no extra code in libsndfile, achieve
exactly what is required and work now.
</P>

<!-- ========================================================================= -->

<A NAME="Q009"></A>
<H2><BR><B>Q9 : Reading a 16 bit PCM file as normalised floats and then 
	writing them back changes some sample values. Why?</B></H2>

<P>
This is caused by the fact that the conversion from 16 bit short to float is
done by dividing by 32768 (0x8000 in hexadecimal) while the conversion from
float to 16 bit short is done by multiplying by 32767 (0x7FFF in hex).
So for instance, a value in a 16 bit PCM file of 20000 gets read as a floating
point number of 0.6103515625 (20000.0 / 0x8000). 
Converting that back to a 16 bit short results in a value of 19999.3896484375
(0.6103515625 * 0x7FFF) which then gets rounded down to 19999.
</P>
<P>
You will notice that for this particular case, the error is 1 in 20000 or 
0.005%.
Interestingly, for values of less than 16369, dividing by 0x8000 followed
by multiplying by 0x7FFF and then rounding the result, gives back the
original value.
It turns out that as long as the host operating system supplies the 1999 ISO
C Standard functions <B>lrintf</B> and <B>lrint</B> (or a replacement has 
been supplied) then the maximum possible error is 1 in 16369 or about 0.006%.
</P>
<P>
Regardless of the size of the error, the reason why this is done is rather 
subtle.
</P>
<P>
In a file containing 16 bit PCM samples, the values are restricted to the range
[-32768, 32767] while we want floating point values in the range [-1.0, 1.0].
The only way to do this conversion is to do a floating point division by a value
of 0x8000.
Converting the other way, the only way to ensure that floating point values in
the range [-1.0, 1.0] are within the valid range allowed by a 16 bit short is
to multiply by 0x7FFF.
</P>
<P>
Some people would say that this is a severe short-coming of libsndfile.
I would counter that anybody who is constantly converting back and forth
between 16 bit shorts and normalised floats is going to suffer other losses
in audio quality that they should also be concerned about.
</P>
<P>
The correct way to deal with this problem is to consider 16 bit short data as
a final destination format only, not as an intermediate storage format.
All intermediate data (ie which is going to be processed further) should be 
stored in floating point format which is supported by all of the most common 
file formats.
If floating point files are considered too large (2 times the size of a 16 bit
PCM file), it would also be possible to use 24 bit PCM as an intermediate
storage format (and which is also supported by most common file types).
</P>

<!-- ========================================================================= -->

<A NAME="Q010"></A>
<H2><BR><B>Q10 : I'm having problems with u-law encoded WAV files generated by 
	libsndfile in Winamp. Why?
</B></H2>

<P>
This is actually a Winamp problem.
The official Microsoft spec suggests that the 'fmt ' chunk should be 18 bytes.
Unfortunately at least one of Microsoft's own applications (Sound Recorder on
Win98 I believe) did not accept 18 bytes 'fmt ' chunks.
</P>
<P>
Michael Lee did some experimenting and found that:
</P>
<PRE>
    I have checked that Windows Media Player 9, QuickTime Player 6.4, 
    RealOne Player 2.0 and GoldWave 5.06 can all play u-law files with
    16-byte or 18-byte 'fmt ' chunk. Only Winamp (2.91) and foobar2000 
    are unable to play u-law files with 16-byte 'fmt ' chunk.
</PRE>

<P>
Even this is a very small sampling of all the players out there.
For that reason it is probably not a good idea to change this now because there
is the risk of breaking something that currently works.
</P>

<!-- ========================================================================= -->

<A NAME="Q011"></A>
<H2><BR><B>Q11 : What are samples? What are frames?
</B></H2>

<P>
For a sound file with only one channel, a frame is the same as a sample.
</P>
<P>
For multi channel sound files, a single frame contains a single sample for
each channel.
</P>

<!-- ========================================================================= -->
<HR>
<P>
	The libsndfile home page is here :
		<A HREF="http://www.mega-nerd.com/libsndfile/">
			http://www.mega-nerd.com/libsndfile/</A>.
<BR>
Version : 1.0.9
</P>

</BODY>
</HTML>

<!--
  Do not edit or modify anything in this comment block.
  The arch-tag line is a file identity tag for the GNU Arch 
  revision control system.
 
  arch-tag: 508f827d-b9a7-4a86-8c2f-d82321df91f7
-->
